<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Keep Simple</title><link href="https://zhangjoto.github.io/" rel="alternate"></link><link href="https://zhangjoto.github.io/feeds/docker.atom.xml" rel="self"></link><id>https://zhangjoto.github.io/</id><updated>2014-12-28T00:00:00+08:00</updated><entry><title>为Docker 1.4.0启用overlay存储驱动</title><link href="https://zhangjoto.github.io/wei-docker-140qi-yong-overlaycun-chu-qu-dong.html" rel="alternate"></link><updated>2014-12-28T00:00:00+08:00</updated><author><name>zhangjoto</name></author><id>tag:zhangjoto.github.io,2014-12-28:wei-docker-140qi-yong-overlaycun-chu-qu-dong.html</id><summary type="html">&lt;div class="contents topic" id="contents"&gt;
&lt;p class="topic-title first"&gt;Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id8"&gt;镜像备份&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id9"&gt;更新软件包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id10"&gt;环境重建&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id11"&gt;环境确认&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id12"&gt;恢复备份&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id13"&gt;最终效果&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;自Docker诞生之初，就采用了aufs做为唯一的存储驱动。但因为aufs一直没有进入内核主线，所以各大发行版只有Ubuntu默认包含了aufs支持，这让Docker某种程度上成了专用于Ubuntu的容器技术。&lt;/p&gt;
&lt;p&gt;直到后来红帽工程师为其实现了devicemapper存储驱动，其它发行版上使用Docker的技术门槛才低了许多。但是受内核的devicemapper机制的限制，Docker的devicemapper驱动在性能和资源消耗上相比aufs驱动都仍有差距。&lt;/p&gt;
&lt;p&gt;直到内核版本3.18，另一个unionfs文件系统实现overlayfs并入了内核主线。而Docker（自1.4.0版本开始）在很短的时间内就提供了对overlayfs存储驱动的试验性支持。从此在各大发行版上使用unionfs做为Docker的存储驱动才成为了可能。&lt;/p&gt;
&lt;p&gt;而我本人由于Docker+devicemapper驱动在使用中的&lt;a class="reference external" href="./dockershi-yong-zhong-de-wen-ti-xiao-jie.html"&gt;种种问题&lt;/a&gt;，当然是盼望着尽快试用Docker的overlayfs驱动。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;镜像备份&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;国内下载官方镜像太过费劲，因此在环境更新前要首先将已有的镜像导出。导出使用save命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker save -o /media/Storage/dockers/centos.tar centos:centos6
&lt;span class="gp"&gt;$&lt;/span&gt; docker save -o /media/Storage/dockers/debian.tar debian
&lt;span class="go"&gt;......&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用同样的命令将所有的镜像全部导出备份。而容器则全部删除，这里不多说。&lt;/p&gt;
&lt;p&gt;以下是我docker info命令的完整输出，可以看到我的Docker数据及元数据分别存放在两个逻辑卷上，数据占用空间是8.291GB，共有43个镜像。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker info
&lt;span class="go"&gt;Containers: 0&lt;/span&gt;
&lt;span class="go"&gt;Images: 43&lt;/span&gt;
&lt;span class="go"&gt;Storage Driver: devicemapper&lt;/span&gt;
&lt;span class="go"&gt; Pool Name: docker-254:1-1279-pool&lt;/span&gt;
&lt;span class="go"&gt; Pool Blocksize: 65.54 kB&lt;/span&gt;
&lt;span class="go"&gt; Data file: /dev/vgroot/lvdocker&lt;/span&gt;
&lt;span class="go"&gt; Metadata file: /dev/vgroot/lvdockermeta&lt;/span&gt;
&lt;span class="go"&gt; Data Space Used: 8.291 GB&lt;/span&gt;
&lt;span class="go"&gt; Data Space Total: 17.18 GB&lt;/span&gt;
&lt;span class="go"&gt; Metadata Space Used: 6.197 MB&lt;/span&gt;
&lt;span class="go"&gt; Metadata Space Total: 16.78 MB&lt;/span&gt;
&lt;span class="go"&gt; Library Version: 1.02.92 (2014-11-28)&lt;/span&gt;
&lt;span class="go"&gt;Execution Driver: native-0.2&lt;/span&gt;
&lt;span class="go"&gt;Kernel Version: 3.18.1-1-ARCH&lt;/span&gt;
&lt;span class="go"&gt;Operating System: Arch Linux&lt;/span&gt;
&lt;span class="go"&gt;CPUs: 4&lt;/span&gt;
&lt;span class="go"&gt;Total Memory: 3.753 GiB&lt;/span&gt;
&lt;span class="go"&gt;Name: ksh-zen&lt;/span&gt;
&lt;span class="go"&gt;ID: C56B:VEMA:MS6I:ZUGG:J3MO:53U6:IU7B:4HO2:PRRB:O3O2:HZVM:EEZ4&lt;/span&gt;

&lt;span class="gp"&gt;$&lt;/span&gt; docker images
&lt;span class="go"&gt;REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE&lt;/span&gt;
&lt;span class="go"&gt;ora                 prepared            e50218f3bfab        2 weeks ago         309.7 MB&lt;/span&gt;
&lt;span class="go"&gt;python              3                   474f82d465a5        3 weeks ago         814.9 MB&lt;/span&gt;
&lt;span class="go"&gt;python              3.4                 474f82d465a5        3 weeks ago         814.9 MB&lt;/span&gt;
&lt;span class="go"&gt;python              4.4.2               474f82d465a5        3 weeks ago         814.9 MB&lt;/span&gt;
&lt;span class="go"&gt;python              latest              474f82d465a5        3 weeks ago         814.9 MB&lt;/span&gt;
&lt;span class="go"&gt;postgres            9                   aaab661c1e3e        4 weeks ago         213.1 MB&lt;/span&gt;
&lt;span class="go"&gt;postgres            9.3                 aaab661c1e3e        4 weeks ago         213.1 MB&lt;/span&gt;
&lt;span class="go"&gt;postgres            9.3.5               aaab661c1e3e        4 weeks ago         213.1 MB&lt;/span&gt;
&lt;span class="go"&gt;postgres            latest              aaab661c1e3e        4 weeks ago         213.1 MB&lt;/span&gt;
&lt;span class="go"&gt;debian              latest              f6fab3b798be        6 weeks ago         85.1 MB&lt;/span&gt;
&lt;span class="go"&gt;debian              wheezy              f6fab3b798be        6 weeks ago         85.1 MB&lt;/span&gt;
&lt;span class="go"&gt;debian              7                   f6fab3b798be        6 weeks ago         85.1 MB&lt;/span&gt;
&lt;span class="go"&gt;debian              7.7                 f6fab3b798be        6 weeks ago         85.1 MB&lt;/span&gt;
&lt;span class="go"&gt;centos              centos6             70441cac1ed5        6 weeks ago         215.8 MB&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;确认所有镜像全部成功导出后停止docker。由于有更新内核并重做文件系统的需求，我还要禁止Docker开机自动启动：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo systemctl stop docker
&lt;span class="gp"&gt;$&lt;/span&gt; sudo systemctl disable docker
&lt;span class="go"&gt;Removed symlink /etc/systemd/system/multi-user.target.wants/docker.service.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;更新软件包&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Docker 1.4.0发布后Arch Linux很快就同步到了最新版本，所以我只要直接更新就好：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; yaourt -Sy docker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而3.18的内核虽然很快就进了testing仓库，但却迟迟没有进入core仓库，所以我要临时启用testing仓库：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; su -
&lt;span class="gp"&gt;#&lt;/span&gt; vi /etc/pacman.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将如下两行的注释去掉：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#[testing]
#Include = /etc/pacman.d/mirrorlist
&lt;/pre&gt;
&lt;p&gt;然后再更新内核才能看到我们想要的3.18。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; yaourt -Sy linux
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;内核更新完成之后记得要将/etc/pacman.conf里修改的内容复原。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;环境重建&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;销毁Docker使用的两个逻辑卷及/var/lib/docker目录下所有文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; su -
&lt;span class="gp"&gt;#&lt;/span&gt; lvremove -f /dev/vgroot/lvdocker
&lt;span class="go"&gt;  Logical volume &amp;quot;lvdocker&amp;quot; successfully removed&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; lvremove -f /dev/vgroot/lvdockermeta
&lt;span class="go"&gt;  Logical volume &amp;quot;lvdockermeta&amp;quot; successfully removed&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; rm -rf /var/lib/docker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着重建逻辑卷，创建文件系统并将其挂载，我个人比较偏好使用xfs文件系统，你自己也可以选择ext4：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; lvcreate -L 20G -n lvdocker vgroot
&lt;span class="go"&gt;WARNING: ext4 signature detected on /dev/vgroot/lvdocker at offset 1080. Wipe it? [y/n]: y&lt;/span&gt;
&lt;span class="go"&gt;  Wiping ext4 signature on /dev/vgroot/lvdocker.&lt;/span&gt;
&lt;span class="go"&gt;  Logical volume &amp;quot;lvdocker&amp;quot; created.&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; mkfs -t xfs /dev/vgroot/lvdocker
&lt;span class="go"&gt;meta-data=/dev/vgroot/lvdocker   isize=256    agcount=4, agsize=1310720 blks&lt;/span&gt;
&lt;span class="go"&gt;         =                       sectsz=512   attr=2, projid32bit=1&lt;/span&gt;
&lt;span class="go"&gt;         =                       crc=0        finobt=0&lt;/span&gt;
&lt;span class="go"&gt;data     =                       bsize=4096   blocks=5242880, imaxpct=25&lt;/span&gt;
&lt;span class="go"&gt;         =                       sunit=0      swidth=0 blks&lt;/span&gt;
&lt;span class="go"&gt;naming   =version 2              bsize=4096   ascii-ci=0 ftype=0&lt;/span&gt;
&lt;span class="go"&gt;log      =internal log           bsize=4096   blocks=2560, version=2&lt;/span&gt;
&lt;span class="go"&gt;         =                       sectsz=512   sunit=0 blks, lazy-count=1&lt;/span&gt;
&lt;span class="go"&gt;realtime =none                   extsz=4096   blocks=0, rtextents=0&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; mkdir /var/lib/docker
&lt;span class="gp"&gt;#&lt;/span&gt; mount /dev/vgroot/lvdocker /var/lib/docker
&lt;span class="gp"&gt;#&lt;/span&gt; df
&lt;span class="go"&gt;Filesystem                  1K-blocks      Used Available Use% Mounted on&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/vgroot-lvarch     8125880   4833020   2857048  63% /&lt;/span&gt;
&lt;span class="go"&gt;dev                           1962456         0   1962456   0% /dev&lt;/span&gt;
&lt;span class="go"&gt;run                           1967700       620   1967080   1% /run&lt;/span&gt;
&lt;span class="go"&gt;tmpfs                         1967700         0   1967700   0% /dev/shm&lt;/span&gt;
&lt;span class="go"&gt;tmpfs                         1967700         0   1967700   0% /sys/fs/cgroup&lt;/span&gt;
&lt;span class="go"&gt;tmpfs                         1967700         8   1967692   1% /tmp&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/vgroot-lvboot      999320     47880    882628   6% /boot&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/vgroot-lvvar      1998672    441904   1435528  24% /var&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/vgroot-lvhome    83845120  79331008   4514112  95% /home&lt;/span&gt;
&lt;span class="go"&gt;tmpfs                          393544         4    393540   1% /run/user/1000&lt;/span&gt;
&lt;span class="go"&gt;/dev/sdb1                   167774792 143071912  24702880  86% /media/Storage&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/vgroot-lvdocker  20961280     32928  20928352   1% /var/lib/docker&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了让新文件系统能自动挂载。要以root身份编辑/etc/fstab，加入如下一行内容：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
/dev/mapper/vgroot-lvdocker     /var/lib/docker xfs             rw,relatime,attr2,inode64       0 2
&lt;/pre&gt;
&lt;p&gt;然后就可以将机器重启了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id11"&gt;环境确认&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;重启后/var/lib/docker文件系统应该已经自动挂载，再确认一下新的内核是否包含了overlayfs支持。注意，它对应的内核模块模块实际上叫overlay：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; modinfo
&lt;span class="go"&gt;filename:       /lib/modules/3.18.1-1-ARCH/kernel/fs/overlayfs/overlay.ko.gz&lt;/span&gt;
&lt;span class="go"&gt;alias:          fs-overlay&lt;/span&gt;
&lt;span class="go"&gt;license:        GPL&lt;/span&gt;
&lt;span class="go"&gt;description:    Overlay filesystem&lt;/span&gt;
&lt;span class="go"&gt;author:         Miklos Szeredi &amp;lt;miklos@szeredi.hu&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;depends:&lt;/span&gt;
&lt;span class="go"&gt;intree:         Y&lt;/span&gt;
&lt;span class="go"&gt;vermagic:       3.18.1-1-ARCH SMP preempt mod_unload modversions&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt; cat /proc/filesystems
&lt;span class="go"&gt;nodev   sysfs&lt;/span&gt;
&lt;span class="go"&gt;nodev   rootfs&lt;/span&gt;
&lt;span class="go"&gt;nodev   ramfs&lt;/span&gt;
&lt;span class="go"&gt;nodev   bdev&lt;/span&gt;
&lt;span class="go"&gt;nodev   proc&lt;/span&gt;
&lt;span class="go"&gt;nodev   cgroup&lt;/span&gt;
&lt;span class="go"&gt;nodev   cpuset&lt;/span&gt;
&lt;span class="go"&gt;nodev   tmpfs&lt;/span&gt;
&lt;span class="go"&gt;nodev   devtmpfs&lt;/span&gt;
&lt;span class="go"&gt;nodev   binfmt_misc&lt;/span&gt;
&lt;span class="go"&gt;nodev   debugfs&lt;/span&gt;
&lt;span class="go"&gt;nodev   securityfs&lt;/span&gt;
&lt;span class="go"&gt;nodev   sockfs&lt;/span&gt;
&lt;span class="go"&gt;nodev   pipefs&lt;/span&gt;
&lt;span class="go"&gt;nodev   configfs&lt;/span&gt;
&lt;span class="go"&gt;nodev   devpts&lt;/span&gt;
&lt;span class="go"&gt;nodev   hugetlbfs&lt;/span&gt;
&lt;span class="go"&gt;nodev   autofs&lt;/span&gt;
&lt;span class="go"&gt;nodev   pstore&lt;/span&gt;
&lt;span class="go"&gt;nodev   efivarfs&lt;/span&gt;
&lt;span class="go"&gt;nodev   mqueue&lt;/span&gt;
&lt;span class="go"&gt;        ext3&lt;/span&gt;
&lt;span class="go"&gt;        ext2&lt;/span&gt;
&lt;span class="go"&gt;        ext4&lt;/span&gt;
&lt;span class="go"&gt;nodev   rpc_pipefs&lt;/span&gt;
&lt;span class="go"&gt;nodev   nfs&lt;/span&gt;
&lt;span class="go"&gt;nodev   nfs4&lt;/span&gt;
&lt;span class="go"&gt;        xfs&lt;/span&gt;
&lt;span class="go"&gt;        iso9660&lt;/span&gt;
&lt;span class="go"&gt;        vfat&lt;/span&gt;
&lt;span class="go"&gt;        fuseblk&lt;/span&gt;
&lt;span class="go"&gt;nodev   fuse&lt;/span&gt;
&lt;span class="go"&gt;nodev   fusectl&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这说明新的内核包含了overlayfs支持，但默认没有将对应模块载入。没有关系，只要我们正确的为Docker配置了overlay驱动，Docker服务启动时内核应该就会自动载入overlay模块了。&lt;/p&gt;
&lt;p&gt;因为overlayfs仍是实验特性，因此即便内核升级到了3.18版本，在Arch上Docker也仍然默认采用devicemapper驱动。必须指明参数迫使docker启用overlayfs。因为Arch Linux已经用systemd取代了SysV init脚本，所以我们应该去修改Docker的service文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; su -
&lt;span class="gp"&gt;#&lt;/span&gt; vi /lib/systemd/system/docker.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到文件内容有以ExecStart开头的一行：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ExecStart=/usr/bin/docker -d -H fd://
&lt;/pre&gt;
&lt;p&gt;加入指定存储驱动的参数-s并存盘退出，修改后应该是这个样子：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ExecStart=/usr/bin/docker -d -H fd:// -s overlay
&lt;/pre&gt;
&lt;p&gt;修改了service文件以后，需要让systemd刷新一下再启动服务：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; systemctl daemon-reload
&lt;span class="gp"&gt;#&lt;/span&gt; systemctl start docker
&lt;span class="gp"&gt;#&lt;/span&gt; &lt;span class="nb"&gt;exit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查一下添加的参数是否生效了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker info
&lt;span class="go"&gt;Containers: 0&lt;/span&gt;
&lt;span class="go"&gt;Images: 0&lt;/span&gt;
&lt;span class="go"&gt;Storage Driver: overlay&lt;/span&gt;
&lt;span class="go"&gt;Execution Driver: native-0.2&lt;/span&gt;
&lt;span class="go"&gt;Kernel Version: 3.18.1-1-ARCH&lt;/span&gt;
&lt;span class="go"&gt;Operating System: Arch Linux&lt;/span&gt;
&lt;span class="go"&gt;CPUs: 4&lt;/span&gt;
&lt;span class="go"&gt;Total Memory: 3.753 GiB&lt;/span&gt;
&lt;span class="go"&gt;Name: ksh-zen&lt;/span&gt;
&lt;span class="go"&gt;ID: C56B:VEMA:MS6I:ZUGG:J3MO:53U6:IU7B:4HO2:PRRB:O3O2:HZVM:EEZ4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到&amp;quot;Storage Driver&amp;quot;后面是overlay，设定的参数起作用了。&lt;/p&gt;
&lt;p&gt;看看/var/lib/docker文件系统下是什么情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; ls /var/lib/docker
&lt;span class="go"&gt;containers  execdriver  graph  init  linkgraph.db  overlay  repositories-overlay  tmp  trust  volumes&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; du -sh /var/lib/docker/*
&lt;span class="go"&gt;0       /var/lib/docker/containers&lt;/span&gt;
&lt;span class="go"&gt;0       /var/lib/docker/execdriver&lt;/span&gt;
&lt;span class="go"&gt;0       /var/lib/docker/graph&lt;/span&gt;
&lt;span class="go"&gt;7.3M    /var/lib/docker/init&lt;/span&gt;
&lt;span class="go"&gt;8.0K    /var/lib/docker/linkgraph.db&lt;/span&gt;
&lt;span class="go"&gt;0       /var/lib/docker/overlay&lt;/span&gt;
&lt;span class="go"&gt;4.0K    /var/lib/docker/repositories-overlay&lt;/span&gt;
&lt;span class="go"&gt;0       /var/lib/docker/tmp&lt;/span&gt;
&lt;span class="go"&gt;0       /var/lib/docker/trust&lt;/span&gt;
&lt;span class="go"&gt;0       /var/lib/docker/volumes&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;目录下面的子目录等自动创建，且大部分目录都是空的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;恢复备份&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;将之前备份的所有镜像全部重新导入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker load -i /media/Storage/dockers/centos.tar
&lt;span class="gp"&gt;$&lt;/span&gt; docker load -i /media/Storage/dockers/debian.tar
&lt;span class="go"&gt;......&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入完成之后还要确认一下镜像是可用的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker run -it centos:centos6 /bin/bash
&lt;span class="go"&gt;[root@147c15762dfa /]#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id13"&gt;最终效果&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;至此为Docker 1.4.0启用overlay驱动的操作算是全部完成，数据也全部安全迁移到了新的Docker环境下。看一看这么一番折腾是否解决了我的问题：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker info
&lt;span class="go"&gt;Containers: 0&lt;/span&gt;
&lt;span class="go"&gt;Images: 43&lt;/span&gt;
&lt;span class="go"&gt;Storage Driver: overlay&lt;/span&gt;
&lt;span class="go"&gt;Execution Driver: native-0.2&lt;/span&gt;
&lt;span class="go"&gt;Kernel Version: 3.18.1-1-ARCH&lt;/span&gt;
&lt;span class="go"&gt;Operating System: Arch Linux&lt;/span&gt;
&lt;span class="go"&gt;CPUs: 4&lt;/span&gt;
&lt;span class="go"&gt;Total Memory: 3.753 GiB&lt;/span&gt;
&lt;span class="go"&gt;Name: ksh-zen&lt;/span&gt;
&lt;span class="go"&gt;ID: C56B:VEMA:MS6I:ZUGG:J3MO:53U6:IU7B:4HO2:PRRB:O3O2:HZVM:EEZ4&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt; df -h
&lt;span class="go"&gt;Filesystem                   Size  Used Avail Use% Mounted on&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/vgroot-lvarch    7.8G  4.7G  2.8G  63% /&lt;/span&gt;
&lt;span class="go"&gt;dev                          1.9G     0  1.9G   0% /dev&lt;/span&gt;
&lt;span class="go"&gt;run                          1.9G  628K  1.9G   1% /run&lt;/span&gt;
&lt;span class="go"&gt;tmpfs                        1.9G     0  1.9G   0% /dev/shm&lt;/span&gt;
&lt;span class="go"&gt;tmpfs                        1.9G     0  1.9G   0% /sys/fs/cgroup&lt;/span&gt;
&lt;span class="go"&gt;tmpfs                        1.9G  8.0K  1.9G   1% /tmp&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/vgroot-lvvar     2.0G  432M  1.4G  24% /var&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/vgroot-lvboot    976M   47M  862M   6% /boot&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/vgroot-lvdocker   20G  1.6G   19G   8% /var/lib/docker&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/vgroot-lvhome     80G   76G  4.4G  95% /home&lt;/span&gt;
&lt;span class="go"&gt;tmpfs                        385M  4.0K  385M   1% /run/user/1000&lt;/span&gt;
&lt;span class="go"&gt;/dev/sdb1                    161G  137G   24G  86% /media/Storage&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样是43个镜像，空间占用由8.291GB变成了1.6GB，效果明显。&lt;/p&gt;
&lt;p&gt;接下来我打算用一两篇文章对overlay的内部机制和它可能带来的好处做一个简单的分析，希望能讲清楚。&lt;/p&gt;
&lt;/div&gt;
</summary><category term="docker"></category><category term="容器技术"></category><category term="overlayfs"></category></entry><entry><title>Docker使用中的问题小结</title><link href="https://zhangjoto.github.io/dockershi-yong-zhong-de-wen-ti-xiao-jie.html" rel="alternate"></link><updated>2014-12-22T00:00:00+08:00</updated><author><name>zhangjoto</name></author><id>tag:zhangjoto.github.io,2014-12-22:dockershi-yong-zhong-de-wen-ti-xiao-jie.html</id><summary type="html">&lt;div class="contents topic" id="contents"&gt;
&lt;p class="topic-title first"&gt;Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id7"&gt;环境说明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id8"&gt;各种问题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id9"&gt;部分命令的临时空间需求问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id10"&gt;空间虚耗问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#commit" id="id11"&gt;commit性能问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id5" id="id12"&gt;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;话说上次利用Docker建立Oracle测试环境之后，环境创建和销毁都成了很轻松的事情，我似乎从此过上了幸福快乐的日子。无奈美梦从来最易醒，在这段时间的使用过程中，理想与现实的差距却逐步暴露了出来。其中一些问题甚至直接影响到Docker的可用性，让人实在不吐不快。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;环境说明&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;吐槽之前得说明一下我对Docker的使用方式。先看一眼Docker的服务启动文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; cat /lib/systemd/system/docker.service
&lt;span class="go"&gt;[Unit]&lt;/span&gt;
&lt;span class="go"&gt;Description=Docker Application Container Engine&lt;/span&gt;
&lt;span class="go"&gt;Documentation=http://docs.docker.com&lt;/span&gt;
&lt;span class="go"&gt;After=network.target docker.socket&lt;/span&gt;
&lt;span class="go"&gt;Requires=docker.socket&lt;/span&gt;

&lt;span class="go"&gt;[Service]&lt;/span&gt;
&lt;span class="go"&gt;ExecStart=/usr/bin/docker -d -H fd:// --storage-opt dm.datadev=/dev/vgroot/lvdocker --storage-opt dm.metadatadev=/dev/vgroot/lvdockermeta&lt;/span&gt;
&lt;span class="go"&gt;LimitNOFILE=1048576&lt;/span&gt;
&lt;span class="go"&gt;LimitNPROC=1048576&lt;/span&gt;

&lt;span class="go"&gt;[Install]&lt;/span&gt;
&lt;span class="go"&gt;WantedBy=multi-user.target&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到我在docker启动命令行后面自己加了两个storage-opt参数，主要目的是为了让Docker使用原始物理设备（逻辑卷）做为数据和元数据的存储空间。根据红帽工程师的测试[#]，Arch下Docker默认的loop-lvm模型无论是IO性能还是资源消耗（主要是cache）都是几种模型中最差的。因此我根据测试结果采用了direct-lvm模型。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;各种问题&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我是使用128G的SSD做为笔记本的本地硬盘，这显然决定了我是一个空间敏感的用户。所以就从空间的使用开始说一说。&lt;/p&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id9"&gt;部分命令的临时空间需求问题&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我创建了大小为20G的逻辑卷用做Docker的存储池（这几乎是我全部的剩余空间了），另外有几十M做为Docker的元数据存储空间。想一想常见的容器一般也就是300～400M上下，个人使用这样设置应该是不会有空间问题了吧？No。&lt;/p&gt;
&lt;p&gt;我们来看一个例子。&lt;/p&gt;
&lt;p&gt;首先打开两个终端，分别把它们叫做A终端和B终端。A终端准备运行docker命令，而B终端则要先su到root并执行两条命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; su -
&lt;span class="gp"&gt;#&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; /var/lib/docker
&lt;span class="gp"&gt;#&lt;/span&gt; du -sh tmp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来从你已有的镜像中挑选一个大小合适的准备导出。大小合适的意思是要导出时间足够长，保证你来得及切换终端执行其它的命令；又不至于让时间长得让人失去耐心。我自己选取的是centos6的官方镜像，记得导出命令要在A终端执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker save -o /tmp/centos.tar centos:centos6
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在马上切换到B终端不断的执行一条命令直到A终端的docker save命令执行完毕：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; du -sh tmp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以看到tmp的占用空间大小在导出过程中会逐渐增长，最大的时候与导出镜像的大小相近，导出完成的时候又变为0。&lt;/p&gt;
&lt;p&gt;这个现象不仅在执行save命令时存在，load/build命令也是一样。程序运行中使用一些临时空间是正常的，但是这样设计至少面临几个问题：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;在Linux的一般使用场景中，/var通常建议划分为单独的文件系统，而且使用者往往认为该文件系统下存放的主要是系统日志和软件更新包的缓存。这就决定了/var文件系统通常不会太大；&lt;/li&gt;
&lt;li&gt;/var文件空间不足会使得docker save之类的操作报错&amp;quot;no space left on device&amp;quot;，但Docker使用者判断不出到底什么空间不足，因为存储池空间富裕，而docker info的输出完全看不到临时空间的状况；&lt;/li&gt;
&lt;li&gt;空间不足导致docker save失败之后，临时文件是自动删除还是不自动删除都会有问题：如果删除，Docker使用者更难判断问题所在；如果不删除，Docker使用者（开发者）就需要寻求系统管理员的帮助，而且系统日志还可能会丢失信息；&lt;/li&gt;
&lt;li&gt;如果/var文件系统空间不足是唯一的问题，要么就得删除文件系统内的其他数据，要么就要进行文件系统扩容。前者可能会妨碍系统管理员的工作，甚至是违反某种合规性；后者的代价可能是服务器停机，毕竟不是所有文件系统都支持在线扩容，何况底层还可能不是lvm而是分区；&lt;/li&gt;
&lt;li&gt;Docker的设计是一个server可以同时多个client的请求，这意味着在大型团队里这个临时空间问题还会随着团队规模而更加放大（也许Docker开发团队认为这些都是很少有人使用的命令）；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总的来说，我个人认为临时空间放在/var/lib/docker/tmp目录下问题较多：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;临时空间与存储池空间不共用需要系统安装时做更详细的规划和计算，且错误一旦出现就需要开发者有较强的技术能力来做判断；&lt;/li&gt;
&lt;li&gt;占用（习惯上的）系统日志和缓存空间会导致系统管理员和开发者互相干涉；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至今我还没有看到Docker有相关的最佳实践介绍，但如果有的话，我一定会建议加上一句：&lt;strong&gt;为/var/lib/docker创建单独的文件系统。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;空间虚耗问题&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;所谓空间虚耗，顾名思义就是有些空间不知道被用到哪去了。还是来看一看例子。&lt;/p&gt;
&lt;p&gt;下面是我的机器目前所有的镜像：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker images
&lt;span class="go"&gt;REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE&lt;/span&gt;
&lt;span class="go"&gt;ora                 prepared            e50218f3bfab        2 weeks ago         309.7 MB&lt;/span&gt;
&lt;span class="go"&gt;python              3                   474f82d465a5        3 weeks ago         814.9 MB&lt;/span&gt;
&lt;span class="go"&gt;python              3.4                 474f82d465a5        3 weeks ago         814.9 MB&lt;/span&gt;
&lt;span class="go"&gt;python              3.4.2               474f82d465a5        3 weeks ago         814.9 MB&lt;/span&gt;
&lt;span class="go"&gt;python              latest              474f82d465a5        3 weeks ago         814.9 MB&lt;/span&gt;
&lt;span class="go"&gt;postgres            9                   aaab661c1e3e        4 weeks ago         213.1 MB&lt;/span&gt;
&lt;span class="go"&gt;postgres            9.3                 aaab661c1e3e        4 weeks ago         213.1 MB&lt;/span&gt;
&lt;span class="go"&gt;postgres            9.3.5               aaab661c1e3e        4 weeks ago         213.1 MB&lt;/span&gt;
&lt;span class="go"&gt;postgres            latest              aaab661c1e3e        4 weeks ago         213.1 MB&lt;/span&gt;
&lt;span class="go"&gt;debian              latest              f6fab3b798be        6 weeks ago         85.1 MB&lt;/span&gt;
&lt;span class="go"&gt;debian              wheezy              f6fab3b798be        6 weeks ago         85.1 MB&lt;/span&gt;
&lt;span class="go"&gt;debian              7                   f6fab3b798be        6 weeks ago         85.1 MB&lt;/span&gt;
&lt;span class="go"&gt;debian              7.7                 f6fab3b798be        6 weeks ago         85.1 MB&lt;/span&gt;
&lt;span class="go"&gt;centos              centos6             70441cac1ed5        6 weeks ago         215.8 MB&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看着虽然不少，但数数IMAGE ID可以看到实际上只有ora/python/postgres/debian/centos这五个不重复的镜像。就算完全不考虑镜像间共享数据的可能，这五个镜像加起来也就是占用1.7G不到的样子。而它们在存储池里的实际使用的空间是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker info
&lt;span class="go"&gt;Containers: 0&lt;/span&gt;
&lt;span class="go"&gt;Images: 43&lt;/span&gt;
&lt;span class="go"&gt;Storage Driver: devicemapper&lt;/span&gt;
&lt;span class="go"&gt; Pool Name: docker-254:1-1279-pool&lt;/span&gt;
&lt;span class="go"&gt; Pool Blocksize: 65.54 kB&lt;/span&gt;
&lt;span class="go"&gt; Data file: /dev/vgroot/lvdocker&lt;/span&gt;
&lt;span class="go"&gt; Metadata file: /dev/vgroot/lvdockermeta&lt;/span&gt;
&lt;span class="go"&gt; Data Space Used: 8.291 GB&lt;/span&gt;
&lt;span class="go"&gt; Data Space Total: 17.18 GB&lt;/span&gt;
&lt;span class="go"&gt; Metadata Space Used: 6.197 MB&lt;/span&gt;
&lt;span class="go"&gt; Metadata Space Total: 16.78 MB&lt;/span&gt;
&lt;span class="go"&gt; Library Version: 1.02.92 (2014-11-28)&lt;/span&gt;
&lt;span class="go"&gt;Execution Driver: native-0.2&lt;/span&gt;
&lt;span class="go"&gt;Kernel Version: 3.18.1-1-ARCH&lt;/span&gt;
&lt;span class="go"&gt;Operating System: Arch Linux&lt;/span&gt;
&lt;span class="go"&gt;CPUs: 4&lt;/span&gt;
&lt;span class="go"&gt;Total Memory: 3.753 GiB&lt;/span&gt;
&lt;span class="go"&gt;Name: ksh-zen&lt;/span&gt;
&lt;span class="go"&gt;ID: C56B:VEMA:MS6I:ZUGG:J3MO:53U6:IU7B:4HO2:PRRB:O3O2:HZVM:EEZ4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.7G对8.291G，空间的有效利用率大概只有20%多一点点。注意，这是我删除了所有其它容器的结果。&lt;/p&gt;
&lt;p&gt;而创建容器的结果又是如何呢？我之前有一个安装了Oracle 11.2.0.4的软件并创建了数据库的镜像（参见我之前的&lt;a class="reference external" href="./li-yong-dockerjian-li-oracle-11gshi-yan-huan-jing.html"&gt;blog文章&lt;/a&gt;），我观察到的现象是利用这个镜像创建一个容器，启动数据库并执行几个查询，再关闭数据库和容器之后，存储池的空间占用增加了100多M。而此时容器内部的变化只是多产生了一些数据库日志文件，加起来还不到1M。&lt;/p&gt;
&lt;p&gt;其实对于这个空间利用率低的问题，从原理分析是可以有很好的解释的：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Docker的devicemapper驱动是利用lvm的snapshot的机制来实现对镜像的复用的；&lt;/li&gt;
&lt;li&gt;lvm的snapshot机制实现的是对块的变化跟踪，目前lvm的块（PE）默认值是4M；&lt;/li&gt;
&lt;li&gt;也就是说，就算只有一个文件的一个字节发生了变化，按snapshot的机制也起码要复制4M的数据；&lt;/li&gt;
&lt;li&gt;多个文件发生改变时，复制的数据量既不取决于变化的数据量，也不取决于这些文件的总数据量，而是取决于这些文件存储时落在多少个数据块上；&lt;/li&gt;
&lt;li&gt;不幸的是，一般镜像里都是大量的小文件，而且linux下的软件包通常都是usr/var/etc/lib等目录各放一部分文件，这意味着文件的布局也是零散的；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以在docker没有也不可能对文件布局进行控制的情况下，空间利用率低到20%也不是什么奇怪的事情。&lt;/p&gt;
&lt;p&gt;但是解释归解释，20%的存储效率是换谁都难以接受的，更何况继续使用下去还有可能更低。这种完全无法预测的空间需求，让系统管理员如何是好呢？&lt;/p&gt;
&lt;p&gt;多说一句，实际上我就多次因为存储池空间爆掉而被迫清理镜像。&lt;/p&gt;
&lt;p&gt;所以我很怀疑是否真有在实际使用环境采用devicemapper驱动的案例。红帽工程师虽然对各种存储驱动做了全面的性能对比测试，但也许他们开发devicemapper驱动的初衷只是为了让广大发行版用户不用编译内核就能试用Docker而已。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12月28日更新：&lt;/strong&gt;我在另一台机器安装的CentOS 7环境上做了同样的测试，使用devicemappr驱动+loop-lvm的情况下，空间占用约为1.9G左右。所以可能这个问题仅在使用devicemapper驱动+direct-lvm的场景下会出现，或是有这么严重。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="commit"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id11"&gt;commit性能问题&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个问题简单来说，就是当容器大一点的情况下，将其提交为镜像的操作耗时很长。而且同时top观察系统的iowait也达到了40%乃至更高（别忘了我的硬盘是SSD），即便是容器相对于基础镜像改变很小的情况也是如此。&lt;/p&gt;
&lt;p&gt;我怀疑这个问题与空间虚耗存在相关性。我个人的猜测是lvm的snapshot机制与Docker的镜像分层粒度不一致，因此在commit的时候Docker需要扫描所有的数据块，将容器中改变的实际文件全部找出来才能生成新的镜像层（fs layer）。&lt;/p&gt;
&lt;p&gt;不过对于这个猜测我还没有想到什么进一步验证的办法，所以就不展开讲了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id12"&gt;小结&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;基于上面的种种经验教训，如果要我对打算尝试Docker的同学说两句，我会说Docker很美好，但记得两件事：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;只要保证系统不整垮，那就尽一切可能上unionfs如aufs等，而不是采用devicemapper存储驱动；&lt;/li&gt;
&lt;li&gt;单独创建一个文件系统挂载到/var/lib/docker，这会为你减少很多麻烦。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后说一句，overlayfs并入3.18的内核主线了，我很期待。&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="id6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[1]&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://developerblog.redhat.com/2014/09/30/overview-storage-scalability-docker/"&gt;Comprehensive Overview of Storage Scalability in Docker&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</summary><category term="Docker"></category><category term="容器技术"></category></entry><entry><title>利用Docker建立Oracle 11g实验环境</title><link href="https://zhangjoto.github.io/li-yong-dockerjian-li-oracle-11gshi-yan-huan-jing.html" rel="alternate"></link><updated>2014-10-20T00:00:00+08:00</updated><author><name>zhangjoto</name></author><id>tag:zhangjoto.github.io,2014-10-20:li-yong-dockerjian-li-oracle-11gshi-yan-huan-jing.html</id><summary type="html">&lt;div class="contents topic" id="contents"&gt;
&lt;p class="topic-title first"&gt;Contents&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id1" id="id24"&gt;基本信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id2" id="id25"&gt;宿主机调整&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id3" id="id26"&gt;空间问题解决&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#kvm" id="id27"&gt;直接从kvm虚拟机迁移&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id4" id="id28"&gt;虚拟机硬盘挂载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id6" id="id29"&gt;文件系统导入&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#docker" id="id30"&gt;Docker环境下重新安装&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id7" id="id31"&gt;基础镜像准备&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#base-image" id="id32"&gt;获取官方Base Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#oracle" id="id33"&gt;Oracle安装准备&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id11" id="id34"&gt;图形化方式安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#id14" id="id35"&gt;静默安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#dockerfile" id="id36"&gt;Dockerfile方式静默安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#image" id="id37"&gt;环境清理并创建Image&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;最近一直在研究Docker，尝试拿它做一些小型的开发试验环境，确实是相当好用。&lt;/p&gt;
&lt;p&gt;某日突发奇想，打算将我的Oracle实验环境迁到Docker中来。虽然最终得到的镜像有点头重脚轻，不太符合Docker推荐的使用方式，但相比虚拟机好歹也节省了些开销。&lt;/p&gt;
&lt;p&gt;实验过程中各种方式折腾了好几轮，感觉都不太完美。先将过程做个记录，期望将来能找到更好的办法。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id24"&gt;基本信息&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我的笔记本本地硬盘是128G的SSD，所以实验过程中使用了外置硬盘做存储，好在是USB3.0连接。另外，基本的软件版本信息如下：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
OS: Arch Linux (内核3.16.4-1)64位
Docker: 1:1.3.0-1
容器OS: CentOS 6.5
Oracle: 11.2.0.4
&lt;/pre&gt;
&lt;p&gt;为了便于区分容器内外进行的操作，我将容器内部进行操作时的命令提示符全部设为 myDocker$ 或 myDocker# ，容器外部的命令提示符则是 $ 或 #。&lt;/p&gt;
&lt;p&gt;此外，为了避免每次使用Docker命令都要sudo或者考虑权限的问题，我将当前用户（swen）加入了docker组：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; gpasswd -a swen docker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记得正在使用的当前用户要重新登录。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id25"&gt;宿主机调整&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我自用的发行版是Arch Linux，利用Docker安装Oracle的话还有个问题要先解决：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;几年前安装的操作系统时，只为/var划了2G空间，但Docker的所有数据默认放在/var/lib/docker目录下，文件系统空间远远不能满足需要；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此在正式开始搭建Oracle实验环境前，我现有的宿主机系统上要做一些调整。&lt;/p&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id26"&gt;空间问题解决&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;先查看一下当前环境的情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker info
&lt;span class="go"&gt;Containers: 0&lt;/span&gt;
&lt;span class="go"&gt;Images: 0&lt;/span&gt;
&lt;span class="go"&gt;Storage Driver: devicemapper&lt;/span&gt;
&lt;span class="go"&gt; Pool Name: docker-254:1-2988-pool&lt;/span&gt;
&lt;span class="go"&gt; Pool Blocksize: 65.54 kB&lt;/span&gt;
&lt;span class="go"&gt; Data file: /var/lib/docker/devicemapper/devicemapper/data&lt;/span&gt;
&lt;span class="go"&gt; Metadata file: /var/lib/docker/devicemapper/devicemapper/metadata&lt;/span&gt;
&lt;span class="go"&gt; Data Space Used: 305.7 MB&lt;/span&gt;
&lt;span class="go"&gt; Data Space Total: 107.4 GB&lt;/span&gt;
&lt;span class="go"&gt; Metadata Space Used: 729.1 kB&lt;/span&gt;
&lt;span class="go"&gt; Metadata Space Total: 2.147 GB&lt;/span&gt;
&lt;span class="go"&gt; Library Version: 1.02.90 (2014-09-01)&lt;/span&gt;
&lt;span class="go"&gt;Execution Driver: native-0.2&lt;/span&gt;
&lt;span class="go"&gt;Kernel Version: 3.16.4-1-ARCH&lt;/span&gt;
&lt;span class="go"&gt;Operating System: Arch Linux&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到Arch Linux上安装的Docker默认使用的devicemapper存储驱动，而数据主要是存放在如下文件中：&lt;/p&gt;
&lt;blockquote&gt;
/var/lib/docker/devicemapper/devicemapper/data&lt;/blockquote&gt;
&lt;p&gt;很显然，我们可以利用软链接解决/var文件系统空间不足的问题。虽然出于性能方面的考虑我最终选择了逻辑卷存储为长期方案，不过实验的过程中空间需求不是个小问题，我决定暂时先利用外置硬盘上的空间。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; su -
&lt;span class="gp"&gt;#&lt;/span&gt; mount /dev/vgusb/lvfiles /media/storage
&lt;span class="gp"&gt;#&lt;/span&gt; systemctl stop docker
&lt;span class="gp"&gt;#&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; /var/lib
&lt;span class="gp"&gt;#&lt;/span&gt; rm -rf docker
&lt;span class="gp"&gt;#&lt;/span&gt; mkdir /media/storeage/docker6
&lt;span class="gp"&gt;#&lt;/span&gt; ln -s /media/storeage/docker6 docker
&lt;span class="gp"&gt;#&lt;/span&gt; systemctl start docker
&lt;span class="gp"&gt;#&lt;/span&gt; &lt;span class="nb"&gt;exit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了建立一个完全干净的Docker环境，我的例子中是选择将整个docker目录删除。要注意&lt;strong&gt;这样做会丢失全部已有的镜像、容器以及元数据。&lt;/strong&gt;如果想要仍然保留原有的所有数据，那就将docker移动到你想要的地方并创建软链接。&lt;/p&gt;
&lt;p&gt;再次查看docker的全局信息，可以看到docker已经检测到/var/lib/docker是一个软链接。并自动在/media/storage/docker6目录下执行初始化，重建了所有子目录以及文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker info
&lt;span class="go"&gt;Containers: 0&lt;/span&gt;
&lt;span class="go"&gt;Images: 0&lt;/span&gt;
&lt;span class="go"&gt;Storage Driver: devicemapper&lt;/span&gt;
&lt;span class="go"&gt; Pool Name: docker-254:8-144185831-pool&lt;/span&gt;
&lt;span class="go"&gt; Pool Blocksize: 65.54 kB&lt;/span&gt;
&lt;span class="go"&gt; Data file: /media/storage/docker6/devicemapper/devicemapper/data&lt;/span&gt;
&lt;span class="go"&gt; Metadata file: /media/storage/docker6/devicemapper/devicemapper/metadata&lt;/span&gt;
&lt;span class="go"&gt; Data Space Used: 305.7 MB&lt;/span&gt;
&lt;span class="go"&gt; Data Space Total: 107.4 GB&lt;/span&gt;
&lt;span class="go"&gt; Metadata Space Used: 356.4 kB&lt;/span&gt;
&lt;span class="go"&gt; Metadata Space Total: 2.147 GB&lt;/span&gt;
&lt;span class="go"&gt; Library Version: 1.02.90 (2014-09-01)&lt;/span&gt;
&lt;span class="go"&gt;Execution Driver: native-0.2&lt;/span&gt;
&lt;span class="go"&gt;Kernel Version: 3.16.4-1-ARCH&lt;/span&gt;
&lt;span class="go"&gt;Operating System: Arch Linux&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="kvm"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id27"&gt;直接从kvm虚拟机迁移&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;之前我一直使用的Oracle实验环境是一台kvm虚拟机，而Docker支持从已有的tar或tar.gz文件导入镜像。因此如果想快速得到一个可用的环境，从kvm虚拟机生成tar文件导入Docker显然是一个不错的方案。&lt;/p&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id28"&gt;虚拟机硬盘挂载&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我的kvm虚拟机是指定一个名为/dev/vgroot/lvora的逻辑卷为本地硬盘，想生成tar文件首先要读取到其中的所有文件。而且为了保障数据一致性，在虚拟机关闭状态下读取其中的文件是最佳选择。利用loop设备配合几条基础的命令就可以做到这一点&lt;a class="footnote-reference" href="#id16" id="id5"&gt;[1]&lt;/a&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; su -
&lt;span class="gp"&gt;#&lt;/span&gt; losetup -f
&lt;span class="go"&gt;/dev/loop0&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; losetup /dev/loop0 /dev/vgroot/lvora
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先找到系统中空闲的loop设备名，并将虚拟机硬盘安装为loop设备，就可以用fdisk命令查看它的分区表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; fdisk -l /dev/loop0

&lt;span class="go"&gt;Disk /dev/loop0: 8 GiB, 8589934592 bytes, 16777216 sectors&lt;/span&gt;
&lt;span class="go"&gt;Units: sectors of 1 * 512 = 512 bytes&lt;/span&gt;
&lt;span class="go"&gt;Sector size (logical/physical): 512 bytes / 512 bytes&lt;/span&gt;
&lt;span class="go"&gt;I/O size (minimum/optimal): 512 bytes / 512 bytes&lt;/span&gt;
&lt;span class="go"&gt;Disklabel type: dos&lt;/span&gt;
&lt;span class="go"&gt;Disk identifier: 0x000b3009&lt;/span&gt;

&lt;span class="go"&gt;Device       Boot  Start      End  Sectors  Size Id Type&lt;/span&gt;
&lt;span class="go"&gt;/dev/loop0p1 *      2048   165887   163840   80M 83 Linux&lt;/span&gt;
&lt;span class="go"&gt;/dev/loop0p2      165888 16777215 16611328  7.9G 8e Linux LVM&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到虚拟机硬盘分为了两个分区，/dev/loop0p1为虚拟机的/boot分区，/dev/loop0p2是一个lvm物理卷，虚拟机的根分区就在其中。&lt;/p&gt;
&lt;p&gt;遗憾的是fdisk并不会自动为每个分区创建相应的设备文件，所以你在/dev目录下是找不着loop0p1这样的文件的。所幸losetup还支持指定偏移量，把loop0的一部分再映射为另一个loop设备。&lt;/p&gt;
&lt;p&gt;因为/boot分区中的内核、引导器等在容器环境中是没有作用的，所以我直接跳过第一个分区，仅仅执行了物理卷的映射：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; losetup /dev/loop1 /dev/vgroot/lvora -o 84934656  &lt;span class="c"&gt;# 165888 * 512&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; pvscan
&lt;span class="go"&gt;PV /dev/loop1   VG vgroot   lvm2 [7.92 GiB / 0    free]&lt;/span&gt;
&lt;span class="go"&gt;PV /dev/sdb2    VG vgusb    lvm2 [305.76 GiB / 135.76 GiB free]&lt;/span&gt;
&lt;span class="go"&gt;PV /dev/sda2    VG vgroot   lvm2 [114.48 GiB / 3.48 GiB free]&lt;/span&gt;
&lt;span class="go"&gt;Total: 3 [428.16 GiB] / in use: 3 [428.16 GiB] / in no VG: 0 [0   ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pvscan找到的卷组中，/dev/loop1对应的卷组vgroot便是虚拟机硬盘上的根卷组。它与我的笔记本上的卷组重名（习惯问题），为了后续操作方便，要先获取到卷组的UUID，利用UUID将虚拟机中的卷组改名再mount文件系统。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; vgs -v
&lt;span class="go"&gt;    DEGRADED MODE. Incomplete RAID LVs will be processed.&lt;/span&gt;
&lt;span class="go"&gt;    Finding all volume groups&lt;/span&gt;
&lt;span class="go"&gt;    Finding volume group &amp;quot;vgroot&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;    Finding volume group &amp;quot;vgusb&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;    Finding volume group &amp;quot;vgroot&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;    Archiving volume group &amp;quot;vgroot&amp;quot; metadata (seqno 4).&lt;/span&gt;
&lt;span class="go"&gt;    Archiving volume group &amp;quot;vgroot&amp;quot; metadata (seqno 22).&lt;/span&gt;
&lt;span class="go"&gt;    Creating volume group backup &amp;quot;/etc/lvm/backup/vgroot&amp;quot; (seqno 22).&lt;/span&gt;
&lt;span class="go"&gt;  VG     Attr   Ext   #PV #LV #SN VSize   VFree   VG UUID                                VProfile&lt;/span&gt;
&lt;span class="go"&gt;  vgroot wz--n- 4.00m   1   3   0   7.92g      0  WOI3ap-aggr-zh4s-cBNG-PapZ-sLpk-2hhv1v&lt;/span&gt;
&lt;span class="go"&gt;  vgroot wz--n- 4.00m   1   8   0 114.48g   3.48g MNGIRS-1jdd-vMLc-iG7u-39c2-mToI-bSPuOx&lt;/span&gt;
&lt;span class="go"&gt;  vgusb  wz--n- 4.00m   1   4   0 305.76g 135.76g gBHvoJ-0154-aMfS-cyzd-ehTj-KrTF-fdd84I&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; vgrename WOI3ap-aggr-zh4s-cBNG-PapZ-sLpk-2hhv1v vgora
&lt;span class="go"&gt;  Volume group &amp;quot;vgroot&amp;quot; successfully renamed to &amp;quot;vgora&amp;quot;&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; pvscan
&lt;span class="go"&gt;  PV /dev/loop1   VG vgora    lvm2 [7.92 GiB / 0    free]&lt;/span&gt;
&lt;span class="go"&gt;  PV /dev/sdb2    VG vgusb    lvm2 [305.76 GiB / 135.76 GiB free]&lt;/span&gt;
&lt;span class="go"&gt;  PV /dev/sda2    VG vgroot   lvm2 [114.48 GiB / 3.48 GiB free]&lt;/span&gt;
&lt;span class="go"&gt;  Total: 3 [428.16 GiB] / in use: 3 [428.16 GiB] / in no VG: 0 [0   ]&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt; mount /dev/vgora/lvroot /media/ora
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此我们在/media/ora目录下就可以看到虚拟机的根分区的所有文件了。&lt;/p&gt;
&lt;p&gt;要记住容器没有自己的内核，/boot文件系统对其是没有意义的。我的虚拟机硬盘只有/boot和/两个文件系统，因此我只需要将根文件系统mount就可以看到所有我想读取的文件。如果你的虚拟机中还有更多文件系统，那你应该根据实际需求决定哪些要mount。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id29"&gt;文件系统导入&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;接下来将虚拟机中的所有文件导入为Docker的镜像。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; tar --numeric-owner -c -C /media/ora . | docker import - debian:debian7
&lt;span class="go"&gt;5b05b8d7a4645b1fc371f673f9f2c18c75769be83d4c3a3abf594f8340f60a7b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以将虚拟机的文件系统和硬盘全部卸载，让它退休了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; umount /media/ora
&lt;span class="gp"&gt;#&lt;/span&gt; vgchange -a n vgora
&lt;span class="gp"&gt;#&lt;/span&gt; losetup -d /dev/loop1
&lt;span class="gp"&gt;#&lt;/span&gt; losetup -d /dev/loop0
&lt;span class="gp"&gt;#&lt;/span&gt; &lt;span class="nb"&gt;exit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为我的Oracle数据库是使用文件系统存储，所以只要文件导入完成，我的数据库就应该能直接使用了。下面测试一下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker images
&lt;span class="go"&gt;REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE&lt;/span&gt;
&lt;span class="go"&gt;ora11g              latest              5b05b8d7a464        2 minutes ago       6.474 GB&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt; docker run -it ora11g /bin/bash
&lt;span class="go"&gt;myDocker# su - oracle&lt;/span&gt;
&lt;span class="go"&gt;myDocker$ sqlplus &amp;#39;/as sysdba&amp;#39;&lt;/span&gt;

&lt;span class="go"&gt;SQL*Plus: Release 11.2.0.3.0 Production on Sat Oct 25 00:57:22 2014&lt;/span&gt;

&lt;span class="go"&gt;Copyright (c) 1982, 2011, Oracle.  All rights reserved.&lt;/span&gt;


&lt;span class="go"&gt;Connected to:&lt;/span&gt;
&lt;span class="go"&gt;Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production&lt;/span&gt;
&lt;span class="go"&gt;With the Partitioning, OLAP, Data Mining and Real Application Testing options&lt;/span&gt;

&lt;span class="go"&gt;ORACLE instance started.&lt;/span&gt;

&lt;span class="go"&gt;Total System Global Area  304807936 bytes&lt;/span&gt;
&lt;span class="go"&gt;Fixed Size                  2227864 bytes&lt;/span&gt;
&lt;span class="go"&gt;Variable Size             163578216 bytes&lt;/span&gt;
&lt;span class="go"&gt;Database Buffers          134217728 bytes&lt;/span&gt;
&lt;span class="go"&gt;Redo Buffers                4784128 bytes&lt;/span&gt;
&lt;span class="go"&gt;Database mounted.&lt;/span&gt;
&lt;span class="go"&gt;Database opened.&lt;/span&gt;
&lt;span class="go"&gt;SQL&amp;gt; select * from v$tablespace;&lt;/span&gt;

&lt;span class="go"&gt;       TS# NAME                           INC BIG FLA ENC&lt;/span&gt;
&lt;span class="go"&gt;---------- ------------------------------ --- --- --- ---&lt;/span&gt;
&lt;span class="go"&gt;         0 SYSTEM                         YES NO  YES&lt;/span&gt;
&lt;span class="go"&gt;         1 SYSAUX                         YES NO  YES&lt;/span&gt;
&lt;span class="go"&gt;         2 UNDOTBS1                       YES NO  YES&lt;/span&gt;
&lt;span class="go"&gt;         4 USERS                          YES NO  YES&lt;/span&gt;
&lt;span class="go"&gt;         3 TEMP                           NO  NO  YES&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里可以看到从虚拟机迁移来的Oracle版本是11.2.0.3，不过这只是这套环境安装太早的原因，对整个迁移过程没有什么影响。&lt;/p&gt;
&lt;p&gt;至此可以确认Oracle环境已经迁移成功。使用这个方法，必然会把原环境的一些临时性文件带入镜像，造成空间浪费。如果对镜像的空间使用和整洁规范要求很高的话，你要在生成tar包之前手工进行清理。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="docker"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id30"&gt;Docker环境下重新安装&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;穷举Oracle官方和Docker提供的方法，Docker环境下搭建Oracle数据库实验环境的方法不外乎三种：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;容器内命令行执行图形安装&lt;/li&gt;
&lt;li&gt;容器内命令行执行静默安装&lt;/li&gt;
&lt;li&gt;编辑Dockerfile进行静默安装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论选择哪一种，操作系统准备、缺失软件包安装、核心参数修改、用户创建等工作总是要做的。我打算将这些工作做好之后单独创建一个镜像，避免重复劳动。&lt;/p&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id31"&gt;基础镜像准备&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="base-image"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id32"&gt;获取官方Base Image&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Docker官方提供了多种操作系统基础镜像，我们可以直接通过docker命令下载到本地。不过由于众所周知的网络原因，国内用户成功执行这步操作的难度颇高。有几种办法可以破：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;为docker后台进程上HTTP代理&lt;a class="footnote-reference" href="#id17" id="id8"&gt;[2]&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;使用国内镜像代替&lt;a class="footnote-reference" href="#id18" id="id9"&gt;[3]&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;利用openvz的模板&lt;a class="footnote-reference" href="#id19" id="id10"&gt;[4]&lt;/a&gt;导入；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;利用openvz模板的方法我测试过是可行的，不过体积比Docker官方镜像大了不小，所以一般还是建议用代理或者国内镜像好了，有特殊需求的朋友可以考虑openvz的模板。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker pull centos:centos6
&lt;span class="go"&gt;centos:centos6: The image you are pulling has been verified&lt;/span&gt;
&lt;span class="go"&gt;5b12ef8fd570: Pulling fs layer&lt;/span&gt;
&lt;span class="go"&gt;5b12ef8fd570: Download complete&lt;/span&gt;
&lt;span class="go"&gt;68edf809afe7: Download complete&lt;/span&gt;
&lt;span class="go"&gt;511136ea3c5a: Download complete&lt;/span&gt;
&lt;span class="go"&gt;Status: Downloaded newer image for centos:centos6&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt; docker images
&lt;span class="go"&gt;REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE&lt;/span&gt;
&lt;span class="go"&gt;centos              centos6             68edf809afe7        3 weeks ago         212.7 MB&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt;docker info
&lt;span class="go"&gt;Containers: 0&lt;/span&gt;
&lt;span class="go"&gt;Images: 3&lt;/span&gt;
&lt;span class="go"&gt;Storage Driver: devicemapper&lt;/span&gt;
&lt;span class="go"&gt; Pool Name: docker-254:8-144185831-pool&lt;/span&gt;
&lt;span class="go"&gt; Pool Blocksize: 65.54 kB&lt;/span&gt;
&lt;span class="go"&gt; Data file: /media/storage/docker6/devicemapper/devicemapper/data&lt;/span&gt;
&lt;span class="go"&gt; Metadata file: /media/storage/docker6/devicemapper/devicemapper/metadata&lt;/span&gt;
&lt;span class="go"&gt; Data Space Used: 577.7 MB&lt;/span&gt;
&lt;span class="go"&gt; Data Space Total: 107.4 GB&lt;/span&gt;
&lt;span class="go"&gt; Metadata Space Used: 942.1 kB&lt;/span&gt;
&lt;span class="go"&gt; Metadata Space Total: 2.147 GB&lt;/span&gt;
&lt;span class="go"&gt; Library Version: 1.02.90 (2014-09-01)&lt;/span&gt;
&lt;span class="go"&gt;Execution Driver: native-0.2&lt;/span&gt;
&lt;span class="go"&gt;Kernel Version: 3.16.4-1-ARCH&lt;/span&gt;
&lt;span class="go"&gt;Operating System: Arch Linux&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为现在Docker官方的centos最新镜像已经升级到了7.0，所以下载的时候必须指定tag为centos6。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="oracle"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id33"&gt;Oracle安装准备&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;首先在Base Image的基础上安装缺失的软件包：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker run -it centos:centos6 /bin/bash
&lt;span class="go"&gt;myDocker# yum install -y compat-libstdc++-33 elfutils-libelf-devel elfutils-libelf-devel-static ksh libaio libaio-devel libstdc++-devel make numactl-devel sysstat gcc-c++&lt;/span&gt;
&lt;span class="go"&gt;myDocker# yum install -y libXext&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行命令中安装的make/gcc-c++/libaio等一系列软件包是Oracle的官方文档中列出的软件包需求，而缺失libXext则是在实验的过程中发现的问题。如果不安装libXext的话，Oracle安装程序会无法启动。&lt;/p&gt;
&lt;p&gt;接下来是调整核心参数以及用户ulimit相关的限制。按照Oracle官方文档，Linux环境下安装Oracle时核心参数建议值如下：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
fs.aio-max-nr = 1048576
fs.file-max = 6815744
kernel.shmall = 2097152
kernel.shmmax = 4294967295
kernel.shmmni = 4096
kernel.sem = 250 32000 100 128
net.ipv4.ip_local_port_range = 9000 65500
net.core.rmem_default = 262144
net.core.rmem_max = 4194304
net.core.wmem_default = 262144
net.core.wmem_max = 1048576
&lt;/pre&gt;
&lt;p&gt;但实际上，Base Image中一些核心参数（目前主要是共享内存相关）默认值就已经比Oracle的建议值还要大了。经过比对，我去掉了两个shm相关的参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;myDocker# vi /etc/sysctl.conf             # 在文件最后加入以下内容并保存&lt;/span&gt;
&lt;span class="go"&gt;fs.aio-max-nr = 1048576&lt;/span&gt;
&lt;span class="go"&gt;fs.file-max = 6815744&lt;/span&gt;
&lt;span class="go"&gt;kernel.shmmni = 4096&lt;/span&gt;
&lt;span class="go"&gt;kernel.sem = 250 32000 100 128&lt;/span&gt;
&lt;span class="go"&gt;net.ipv4.ip_local_port_range = 9000 65500&lt;/span&gt;
&lt;span class="go"&gt;net.core.rmem_default = 262144&lt;/span&gt;
&lt;span class="go"&gt;net.core.rmem_max = 4194304&lt;/span&gt;
&lt;span class="go"&gt;net.core.wmem_default = 262144&lt;/span&gt;
&lt;span class="go"&gt;net.core.wmem_max = 1048576&lt;/span&gt;

&lt;span class="go"&gt;myDocker# vi /etc/security/limits.conf    # 在文件最后加入以下内容并保存&lt;/span&gt;
&lt;span class="go"&gt;oracle              soft    nproc   2047&lt;/span&gt;
&lt;span class="go"&gt;oracle              hard    nproc   16384&lt;/span&gt;
&lt;span class="go"&gt;oracle              soft    nofile  1024&lt;/span&gt;
&lt;span class="go"&gt;oracle              hard    nofile  65536&lt;/span&gt;
&lt;span class="go"&gt;oracle              soft    stack   10240&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些调整完成以后就可以创建数据库相关的操作系统用户和组了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;myDocker# groupadd -g 601 dba&lt;/span&gt;
&lt;span class="go"&gt;myDocker# groupadd -g 602 oinstall&lt;/span&gt;

&lt;span class="go"&gt;myDocker# useradd -u 601 -m -g oinstall -G dba oracle&lt;/span&gt;
&lt;span class="go"&gt;myDocker# echo &amp;quot;oracle:oracle&amp;quot; | chpasswd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我要做一件官方文档上不可能提到的事情，首先用编辑器打开容器中的fstab：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;myDocker# vi /etc/fstab&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到如下所示的内容：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
LABEL=_/   /        ext4      defaults         0 0
devpts     /dev/pts  devpts  gid=5,mode=620   0 0
tmpfs      /dev/shm  tmpfs   defaults         0 0
proc       /proc     proc    defaults         0 0
sysfs      /sys      sysfs   defaults         0 0
&lt;/pre&gt;
&lt;p&gt;现在我们找到/dev/shm所在的那一行，在defaults后指定其大小为1G。修改后这一行的内容应该是这样的：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tmpfs      /dev/shm  tmpfs   defaults,size=1g         0 0
&lt;/pre&gt;
&lt;p&gt;记得将修改后的文件保存。要做这个修改的原因是Oracle软件产品完毕后使用dbca建库时，建库脚本会利用/dev/shm创建共享内存对象，但Docker为其指定的默认大小（64M）不足以满足需求。所以我在创建数据库前要临时扩展其大小。&lt;/p&gt;
&lt;p&gt;如果不扩展/dev/shm大小的话，建库程序dbca会在执行到76%左右的时候报错挂起。如果你去查看创建数据库的日志（$ORACLE_BASE/cfgtoollogs/dbca/$ORACLE_SID/postDBCreation.log），应该会看到明确的提示。&lt;/p&gt;
&lt;p&gt;不过神奇的是这时候Oracle会在$HOME目录下生成一个名字类似&amp;quot;catbundle_PSU_SAND_GENERATE*.log&amp;quot;的日志，里面告诉你&amp;quot;Error reading bundledata_PSU.xml - patch NOT installed&amp;quot;。不要被它误导，&lt;strong&gt;一定要去看一眼数据库创建的日志文件。&lt;/strong&gt;那里面会是这样写：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
BEGIN
*
ERROR at line 1:
ORA-29516: Aurora assertion failure: Assertion failure at joez.c:3422
Bulk load of method java/lang/Object.&amp;lt;init&amp;gt; failed; insufficient shm-object space
ORA-06512: at line 3


          IF CatbundleCreateDir(:catbundleLogDir) = 0 THEN
                       *
ERROR at line 71:
ORA-06550: line 71, column 14:
PLS-00201: identifier 'CATBUNDLECREATEDIR' must be declared
ORA-06550: line 71, column 11:
PL/SQL: Statement ignored
&lt;/pre&gt;
&lt;p&gt;这个问题经我测试在Oracle for linux 64位的11.2.0.3/11.2.0.4版本都存在，11.2.0.2未测试，11.2.0.1版本倒是不受影响。所以你要根据Oracle软件版本自行决定。&lt;/p&gt;
&lt;p&gt;最后我再偷个懒，提前把oracle用户建库时候要用的环境变量也全部设置好，工作量能省一点是一点：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;myDocker# su - oracle&lt;/span&gt;
&lt;span class="go"&gt;myDocker$ vi .bash_profile                # 在文件最后加入以下行并保存&lt;/span&gt;
&lt;span class="go"&gt;ORACLE_SID=sand&lt;/span&gt;
&lt;span class="go"&gt;ORACLE_BASE=$HOME/server&lt;/span&gt;
&lt;span class="go"&gt;ORACLE_HOME=$ORACLE_BASE/product/11.2/db&lt;/span&gt;
&lt;span class="gp"&gt;PATH=$ORACLE_HOME/bin:$PATH:$&lt;/span&gt;HOME/tools/sbin
&lt;span class="go"&gt;LD_LIBRARY_PATH=$ORACLE_HOME/lib:$LD_LIBRARY_PATH&lt;/span&gt;
&lt;span class="go"&gt;export ORACLE_SID ORACLE_BASE ORACLE_HOME PATH LD_LIBRARY_PATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;环境变量中的软件安装路径和数据库名我都按照自己的喜好修改过，你可以按自己的习惯自行调整，也可以遵循Oracle提供的默认设置。&lt;/p&gt;
&lt;p&gt;至此基础镜像的准备已经全部就绪，现在把这个容器清理一下，再提交为镜像。因为现在我还只有一个容器，所以命令行中Container ID只需输入头几位，让Docker知道我指的是哪一个容器就行了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;myDocker$ exit&lt;/span&gt;
&lt;span class="go"&gt;myDocker# yum clean all&lt;/span&gt;
&lt;span class="go"&gt;myDocker# exit&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt; docker ps -a
&lt;span class="go"&gt;CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES&lt;/span&gt;
&lt;span class="go"&gt;0042412b5d55        centos:centos6      &amp;quot;/bin/bash&amp;quot;         9 minutes ago       Exited (0) 3 seconds ago                       jovial_kowalevski&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt; docker commit -m &lt;span class="s1"&gt;&amp;#39;prepared for oracle install&amp;#39;&lt;/span&gt; 0042 ora11g:prepared
&lt;span class="go"&gt;0042412b5d55348e8868349cf8435123614bc0926674e22dc7382e477d048586&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再检查一下提交是否成功：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker images
&lt;span class="go"&gt;REPOSITORY                      TAG                 IMAGE ID            CREATED             VIRTUAL SIZE&lt;/span&gt;
&lt;span class="go"&gt;ora11g                          prepared            aa5e34846c4e        20 seconds ago      368.6 MB&lt;/span&gt;
&lt;span class="go"&gt;centos                          centos6             68edf809afe7        3 weeks ago         212.7 MB&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实还有更简单一点的方式创建基础镜像，就是利用docker build。现友情赠送创建基础镜像的Dockerfile：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;FROM centos:centos6
MAINTAINER zhangjoto@gmail.com
RUN yum install -y compat-libstdc++-33 \
    elfutils-libelf-devel \
    elfutils-libelf-devel-static \
    ksh \
    libaio \
    libaio-devel \
    libstdc++-devel \
    make \
    numactl-devel \
    sysstat \
    gcc-c++ \
    &amp;amp;&amp;amp; yum install -y libXext \
    &amp;amp;&amp;amp; yum clean all
RUN groupadd -g 601 dba \
    &amp;amp;&amp;amp; groupadd -g 602 oinstall \
    &amp;amp;&amp;amp; useradd -u 601 -g 602 -G 601 -m oracle \
    &amp;amp;&amp;amp; chmod 750 /home/oracle \
    &amp;amp;&amp;amp; echo &amp;quot;oracle:oracle&amp;quot; | chpasswd
RUN echo    &amp;quot;fs.aio-max-nr = 1048576&amp;quot; &amp;gt;&amp;gt;/etc/sysctl.conf \
    &amp;amp;&amp;amp; echo &amp;quot;fs.file-max = 6815744&amp;quot; &amp;gt;&amp;gt;/etc/sysctl.conf \
    &amp;amp;&amp;amp; echo &amp;quot;kernel.shmmni = 4096&amp;quot; &amp;gt;&amp;gt;/etc/sysctl.conf \
    &amp;amp;&amp;amp; echo &amp;quot;kernel.sem = 250 32000 100 128&amp;quot; &amp;gt;&amp;gt;/etc/sysctl.conf \
    &amp;amp;&amp;amp; echo &amp;quot;net.ipv4.ip_local_port_range = 9000 65500&amp;quot; &amp;gt;&amp;gt;/etc/sysctl.conf \
    &amp;amp;&amp;amp; echo &amp;quot;net.core.rmem_default = 262144&amp;quot; &amp;gt;&amp;gt;/etc/sysctl.conf \
    &amp;amp;&amp;amp; echo &amp;quot;net.core.rmem_max = 4194304&amp;quot; &amp;gt;&amp;gt;/etc/sysctl.conf \
    &amp;amp;&amp;amp; echo &amp;quot;net.core.wmem_default = 262144&amp;quot; &amp;gt;&amp;gt;/etc/sysctl.conf \
    &amp;amp;&amp;amp; echo &amp;quot;net.core.wmem_max = 1048576&amp;quot; &amp;gt;&amp;gt;/etc/sysctl.conf
RUN echo    &amp;quot;oracle              soft    nproc   2047&amp;quot; &amp;gt;&amp;gt;/etc/security/limits.conf \
    &amp;amp;&amp;amp; echo &amp;quot;oracle              hard    nproc   16384&amp;quot; &amp;gt;&amp;gt;/etc/security/limits.conf \
    &amp;amp;&amp;amp; echo &amp;quot;oracle              soft    nofile  1024&amp;quot; &amp;gt;&amp;gt;/etc/security/limits.conf \
    &amp;amp;&amp;amp; echo &amp;quot;oracle              hard    nofile  65536&amp;quot; &amp;gt;&amp;gt;/etc/security/limits.conf \
    &amp;amp;&amp;amp; echo &amp;quot;oracle              soft    stack   10240&amp;quot; &amp;gt;&amp;gt; /etc/security/limits.conf
RUN echo    &amp;#39;ORACLE_SID=sand&amp;#39; &amp;gt;&amp;gt;/home/oracle/.bash_profile \
    &amp;amp;&amp;amp; echo &amp;#39;ORACLE_BASE=$HOME/server&amp;#39; &amp;gt;&amp;gt;/home/oracle/.bash_profile \
    &amp;amp;&amp;amp; echo &amp;#39;ORACLE_HOME=$ORACLE_BASE/product/11.2/db&amp;#39; &amp;gt;&amp;gt;/home/oracle/.bash_profile \
    &amp;amp;&amp;amp; echo &amp;#39;PATH=$ORACLE_HOME/bin:$PATH&amp;#39; &amp;gt;&amp;gt;/home/oracle/.bash_profile \
    &amp;amp;&amp;amp; echo &amp;#39;LD_LIBRARY_PATH=$ORACLE_HOME/lib:$LD_LIBRARY_PATH&amp;#39; &amp;gt;&amp;gt;/home/oracle/.bash_profile \
    &amp;amp;&amp;amp; echo &amp;#39;export ORACLE_SID ORACLE_BASE ORACLE_HOME PATH LD_LIBRARY_PATH&amp;#39; &amp;gt;&amp;gt;/home/oracle/.bash_profile
RUN sed -i &amp;#39;/\/dev\/shm/s/defaults/defaults,size=1g/&amp;#39; /etc/fstab
CMD /bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为Dockerfile对多行字符串的支持不太好，所以我用了很多个echo一行一行的向文件追加内容。如果你知道更好的方式（除了预先编辑文件COPY到容器内之外），还请记得留言告诉我。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id34"&gt;图形化方式安装&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;容器是没有自己的图形界面的，想实现图形化安装就得将容器内部的图形程序转发到容器外部来显示。&lt;/p&gt;
&lt;p&gt;通常实现这个目的最简单的方式利用sshd的X11转发功能，但Docker官方并不建议在容器中运行sshd，&lt;a class="footnote-reference" href="#id21" id="id12"&gt;[5]&lt;/a&gt;我也不希望多装软件包。实际上如果不考虑安全性的问题，完全可以通过将X11的socket文件映射到容器内部达到目的。国外已经有人用这种方式运行容器内的Firefox和其它程序&lt;a class="footnote-reference" href="#id22" id="id13"&gt;[6]&lt;/a&gt;。不过随着Docker新版本安全性的增强，原文的办法已不再完全适用，我需要做一点小小的调整（参见原文下面的讨论）。&lt;/p&gt;
&lt;p&gt;首先从准备好的基础镜像创建准备用来安装Oracle数据库的容器，为了方便，我要将它命名为ora。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker run -it --name ora -e DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix -v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/.Xauthority:/root/.Xauthority -v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/ora:/mnt --net&lt;span class="o"&gt;=&lt;/span&gt;host --privileged ora11g:prepared /bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我先解释一下这行命令中各个参数的含义：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;--name 指定容器的名字为ora；&lt;/li&gt;
&lt;li&gt;-e 告诉Docker要将环境变量DISPLAY的值传入容器中；&lt;/li&gt;
&lt;li&gt;-v 将Host的文件映射到容器内部；&lt;ul&gt;
&lt;li&gt;/tmp/.X11-unix：X11协议用到的socket文件就在这个目录；&lt;/li&gt;
&lt;li&gt;$HOME/.Xauthority：使用Host上当前用户的该文件才能通过X11的权限检查；&lt;/li&gt;
&lt;li&gt;$HOME/ora：我的Oracle软件安装介质解压放在这个目录下；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;--net=host 告诉Docker容器直接使用Host的网络协议栈。这个选项是有安全风险的，我仅在需要运行容器中的图形程序时使用；&lt;/li&gt;
&lt;li&gt;--privileged 为容器申请特权。要在容器内改变/dev/shm的大小及设置核心参数都必须指定这个参数；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为容器没有自己的init进程，因此Docker用户自定义的初始化任务都只能手工执行。比如根据fstab挂载文件系统和设置核心参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;myDocker# mount -o remount /dev/shm&lt;/span&gt;
&lt;span class="go"&gt;myDocker# df -h&lt;/span&gt;
&lt;span class="go"&gt;Filesystem            Size  Used Avail Use% Mounted on&lt;/span&gt;
&lt;span class="go"&gt;rootfs                9.8G  388M  8.9G   5% /&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/docker-254:8-144185831-375f693461a71e033bb7c0929713ac81793f25b76d509b28652c45de7f8a0977&lt;/span&gt;
&lt;span class="go"&gt;                      9.8G  388M  8.9G   5% /&lt;/span&gt;
&lt;span class="go"&gt;tmpfs                 1.9G     0  1.9G   0% /dev&lt;/span&gt;
&lt;span class="go"&gt;shm                   1.0G     0  1.0G   0% /dev/shm&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/vgusb-lvfiles&lt;/span&gt;
&lt;span class="go"&gt;                       50G   21G   30G  41% /etc/resolv.conf&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/vgusb-lvfiles&lt;/span&gt;
&lt;span class="go"&gt;                       50G   21G   30G  41% /etc/hostname&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/vgusb-lvfiles&lt;/span&gt;
&lt;span class="go"&gt;                       50G   21G   30G  41% /etc/hosts&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/vgroot-lvhome&lt;/span&gt;
&lt;span class="go"&gt;                       80G   78G  2.3G  98% /mnt&lt;/span&gt;
&lt;span class="go"&gt;/dev/mapper/vgroot-lvhome&lt;/span&gt;
&lt;span class="go"&gt;                       80G   78G  2.3G  98% /root/.Xauthority&lt;/span&gt;
&lt;span class="go"&gt;tmpfs                 1.9G  212K  1.9G   1% /tmp/.X11-unix&lt;/span&gt;

&lt;span class="go"&gt;myDocker# sysctl -p&lt;/span&gt;
&lt;span class="go"&gt;net.ipv4.ip_forward = 0&lt;/span&gt;
&lt;span class="go"&gt;net.ipv4.conf.default.rp_filter = 1&lt;/span&gt;
&lt;span class="go"&gt;net.ipv4.conf.default.accept_source_route = 0&lt;/span&gt;
&lt;span class="go"&gt;kernel.sysrq = 0&lt;/span&gt;
&lt;span class="go"&gt;kernel.core_uses_pid = 1&lt;/span&gt;
&lt;span class="go"&gt;error: &amp;quot;net.ipv4.tcp_syncookies&amp;quot; is an unknown key&lt;/span&gt;
&lt;span class="go"&gt;error: &amp;quot;net.bridge.bridge-nf-call-ip6tables&amp;quot; is an unknown key&lt;/span&gt;
&lt;span class="go"&gt;error: &amp;quot;net.bridge.bridge-nf-call-iptables&amp;quot; is an unknown key&lt;/span&gt;
&lt;span class="go"&gt;error: &amp;quot;net.bridge.bridge-nf-call-arptables&amp;quot; is an unknown key&lt;/span&gt;
&lt;span class="go"&gt;kernel.msgmnb = 65536&lt;/span&gt;
&lt;span class="go"&gt;kernel.msgmax = 65536&lt;/span&gt;
&lt;span class="go"&gt;kernel.shmmax = 68719476736&lt;/span&gt;
&lt;span class="go"&gt;kernel.shmall = 4294967296&lt;/span&gt;
&lt;span class="go"&gt;fs.aio-max-nr = 1048576&lt;/span&gt;
&lt;span class="go"&gt;fs.file-max = 6815744&lt;/span&gt;
&lt;span class="go"&gt;kernel.shmmni = 4096&lt;/span&gt;
&lt;span class="go"&gt;kernel.sem = 250 32000 100 128&lt;/span&gt;
&lt;span class="go"&gt;net.ipv4.ip_local_port_range = 9000 65500&lt;/span&gt;
&lt;span class="go"&gt;error: &amp;quot;net.core.rmem_default&amp;quot; is an unknown key&lt;/span&gt;
&lt;span class="go"&gt;error: &amp;quot;net.core.rmem_max&amp;quot; is an unknown key&lt;/span&gt;
&lt;span class="go"&gt;error: &amp;quot;net.core.wmem_default&amp;quot; is an unknown key&lt;/span&gt;
&lt;span class="go"&gt;error: &amp;quot;net.core.wmem_max&amp;quot; is an unknown key&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到对/dev/shm的修改生效了，而设置核心参数有很多error。不过不用担心，报错的这些参数只有在繁忙的数据库环境下才真的有必要调整。至于个人使用的实验环境，我们直接跳过不去管它就好了。&lt;/p&gt;
&lt;p&gt;接下来为了启用图形化界面还要做点小小的处理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;myDocker# cp ~/.Xauthority ~oracle/&lt;/span&gt;
&lt;span class="go"&gt;myDocker# chown oracle:oinstall ~oracle/.Xauthority&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为这个.Xauthority文件是从Host映射进来的，我不想让容器对外部环境造成干扰，因此为oracle用户单独复制了一份。如果你不想这么做，那就将容器内的oracle用户的uid和gid设为与Host内用户完全一样的值，并在前面启动容器的命令行里将该文件映射为/home/oracle/.Xauthority即可。&lt;/p&gt;
&lt;p&gt;现在设置好Oracle安装介质所在目录的权限就可以开始运行安装程序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;myDocker# chown -R oracle:oinstall /mnt&lt;/span&gt;
&lt;span class="go"&gt;myDocker# su - oracle&lt;/span&gt;
&lt;span class="go"&gt;myDocker$ cd /mnt/database&lt;/span&gt;
&lt;span class="go"&gt;myDocker$ ./runInstaller&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时你就应该能看到熟悉的安装界面了。&lt;/p&gt;
&lt;p&gt;至于剩下的安装过程、建库和执行指定的脚本以及安装后的验证检查等动作都是标准化流程，网上图文并茂的教程一搜就是一大把，我就不再赘述了。唯一需要提到的就是系统需求检查的时候会找不到pdksh包，实际上centos6里它已经改名为ksh，直接忽略警告即可。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id14"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id35"&gt;静默安装&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;静默安装的过程与图形化安装大同小异，除了准备响应文件、建库模板以外只有几个地方不太一样：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;启动容器的命令行更简略，由于是静默安装，所以图形转发相关的参数全都可以去掉：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker run -it --name ora -v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/ora:/mnt --privileged ora11g:prepared /bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;运行安装程序的参数要为静默方式指定响应文件并忽略系统需求检查。响应文件在图形化安装时录制或使用安装介质response目录下提供的模板修改均可。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;myDocker$ ./runInstaller -silent -responseFile /mnt/db.rsp -ignorePrereq&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;运行dbca程序也要指定大量参数：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;myDocker$ dbca -silent -createDatabase -templateName /mnt/sand.dbc \&lt;/span&gt;
&lt;span class="go"&gt;    -gdbname sand -sid sand -sysPassword sys -systemPassword sys \&lt;/span&gt;
&lt;span class="go"&gt;    -characterSet ZHS16GBK -nationalCharacterSet AL16UTF16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据库模板可以从下面的目录获取官方样板来修改：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ORACLE_HOME/assistants/dbca/templates
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="dockerfile"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id36"&gt;Dockerfile方式静默安装&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;废话不多说，先贴上Dockerfile的内容。其中runInstaller多了一个参数&amp;quot;-waitforcompletion&amp;quot;，这是为了等待产品安装过程全部完成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;FROM ora11g:prepared
MAINTAINER zhangjoto@gmail.com
COPY database /mnt/database
COPY db.rsp /mnt/
COPY sand.dbc /mnt/
RUN sysctl -p &amp;amp;&amp;amp; mount -o remount /dev/shm
RUN chown -R oracle:oinstall /mnt &amp;amp;&amp;amp; chown -R oracle:oinstall /home/oracle
RUN su - oracle -c &amp;quot;/mnt/database/runInstaller -silent -responseFile /mnt/db.rsp -ignorePrereq -waitforcompletion&amp;quot;
RUN /home/oracle/oraInventory/orainstRoot.sh \
    &amp;amp;&amp;amp; /home/oracle/server/product/11.2/db/root.sh
USER oracle
RUN . ~/.bash_profile \
    &amp;amp;&amp;amp; dbca -silent -createDatabase -templateName /mnt/sand.dbc \
        -gdbname sand -sid sand -sysPassword sys -systemPassword sys \
        -characterSet ZHS16GBK -nationalCharacterSet AL16UTF16

CMD /bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但我要很遗憾的说，把这个Dockerfile应用于我前面指定的软件版本的话是要失败的。问题出在这一行代码上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;RUN sysctl -p &amp;amp;&amp;amp; mount -o remount /dev/shm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还记得我前面说过的话么？执行这两个命令必须用--privileged参数为容器指定特权，而Dockerfile现在是不支持使用特权的。有些用户在Docker项目主页提交了issue，希望提供RUNP命令或让build支持--privileged参数，但不知官方最终会作何反应。&lt;a class="footnote-reference" href="#id23" id="id15"&gt;[7]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果将来官方对此需求提供了支持，我会回头来修改这一部分的内容。但在此之前，你只能用这个Dockerfile来安装Oracle 11.2.0.1及更低版本的数据库环境，并且记得要删除报错的那一行代码。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="image"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id37"&gt;环境清理并创建Image&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;至此可用于个人使用的Oracle实验环境就搭建完成了。不过为了更适合于个人使用和作为镜像分发，我决定关闭数据库的审计并清理各种临时文件之后再生成镜像。&lt;/p&gt;
&lt;p&gt;下面的过程我不会做太详细的说明，需要研究的朋友应该很容易就能找到相关的详细资料。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;myDocker$ sqlplus &amp;#39;/as sysdba&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;SQL&amp;gt; alter user scott account unlock;&lt;/span&gt;

&lt;span class="go"&gt;User altered.&lt;/span&gt;

&lt;span class="go"&gt;SQL&amp;gt; alter system set audit_trail=none scope=spfile;&lt;/span&gt;

&lt;span class="go"&gt;System altered.&lt;/span&gt;

&lt;span class="go"&gt;SQL&amp;gt; shutdown immediate;&lt;/span&gt;
&lt;span class="go"&gt;Database closed.&lt;/span&gt;
&lt;span class="go"&gt;Database dismounted.&lt;/span&gt;
&lt;span class="go"&gt;ORACLE instance shut down.&lt;/span&gt;
&lt;span class="go"&gt;SQL&amp;gt; startup;&lt;/span&gt;
&lt;span class="go"&gt;ORACLE instance started.&lt;/span&gt;

&lt;span class="go"&gt;Total System Global Area  221294592 bytes&lt;/span&gt;
&lt;span class="go"&gt;Fixed Size                  2251936 bytes&lt;/span&gt;
&lt;span class="go"&gt;Variable Size             125829984 bytes&lt;/span&gt;
&lt;span class="go"&gt;Database Buffers           88080384 bytes&lt;/span&gt;
&lt;span class="go"&gt;Redo Buffers                5132288 bytes&lt;/span&gt;
&lt;span class="go"&gt;Database mounted.&lt;/span&gt;
&lt;span class="go"&gt;Database opened.&lt;/span&gt;
&lt;span class="go"&gt;SQL&amp;gt; truncate table SYS.AUD$;&lt;/span&gt;

&lt;span class="go"&gt;Table truncated.&lt;/span&gt;

&lt;span class="go"&gt;SQL&amp;gt; shutdown immediate;&lt;/span&gt;
&lt;span class="go"&gt;SQL&amp;gt; exit&lt;/span&gt;
&lt;span class="go"&gt;myDocker$ rm $ORACLE_BASE/admin/$ORACLE_SID/adump/*&lt;/span&gt;
&lt;span class="go"&gt;myDocker$ rm -rf $ORACLE_HOME/log/`hostname`&lt;/span&gt;
&lt;span class="go"&gt;myDocker$ rm -rf $ORACLE_HOME/diag/tnslsnr/`hostname`&lt;/span&gt;
&lt;span class="go"&gt;myDocker$ rm -rf /tmp/*&lt;/span&gt;
&lt;span class="go"&gt;myDocker$ exit&lt;/span&gt;
&lt;span class="go"&gt;myDocker# yum clean all&lt;/span&gt;
&lt;span class="go"&gt;myDocker# exit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以生成一个比较干净的镜像了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; docker ps -a
&lt;span class="go"&gt;CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                          PORTS               NAMES&lt;/span&gt;
&lt;span class="go"&gt;375f693461a7        centos:centos6      &amp;quot;/bin/bash&amp;quot;         About an hour ago   Exited (0) About a minute ago                       ora&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt; docker commit -m &lt;span class="s2"&gt;&amp;quot;oracle 11.2.0.4 on centos6&amp;quot;&lt;/span&gt; ora ora11g:11.2.0.4
&lt;span class="go"&gt;0de7ebf0d1998e9acfdd9c1bf0841613ce0345b0f430a99b5b4b41f6df837f08&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt; docker images
&lt;span class="go"&gt;REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE&lt;/span&gt;
&lt;span class="go"&gt;ora11g              11.2.0.4            0de7ebf0d199        15 minutes ago      6.576 GB&lt;/span&gt;
&lt;span class="go"&gt;centos              centos6             68edf809afe7        3 weeks ago         212.7 MB&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，我们终于有了一套容器中的Oracle数据库实验环境。从此我不必：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;忍受虚拟机的资源消耗；&lt;/li&gt;
&lt;li&gt;等待一大堆系统服务的启动与关闭；&lt;/li&gt;
&lt;li&gt;每做一个试验前都要想清楚怎么将环境恢复原状；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我可以：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;随时开启实验环境检验自己的想法；&lt;/li&gt;
&lt;li&gt;频繁创建新的实验环境验证不同的技术方案再销毁；&lt;/li&gt;
&lt;li&gt;放心进行各种破坏性测试而不用担心恢复问题；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相比kvm虚拟机，Docker某些场合会给用户带来更多的自由。&lt;/p&gt;
&lt;p&gt;在这次实验过程中，我对于Docker技术有一些新的理解、感想和希望，另外我们还可以对镜像实施一些优化，使其更易于使用。不过这篇文章写到这里已经太长，我想剩下这些内容还是放在后面的文章里说好了。&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="id16" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://dgc.uchicago.edu/20130530/mounting-a-kvm-disk-image-without-kvm/"&gt;Mounting a KVM disk image without KVM&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id17" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id8"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="https://docs.docker.com/installation/fedora/#http-proxy"&gt;官方文档：HTTP Proxy&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id18" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id9"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://www.dockerpool.com/article/1413082493"&gt;DockerPool FAQ&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id19" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id10"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://www.dockerpool.com/static/books/docker_practice/image/create.html"&gt;创建镜像|Docker----从入门到实践&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id21" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id12"&gt;[5]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://blog.docker.com/2014/06/why-you-dont-need-to-run-sshd-in-docker/"&gt;Why you don't need to run SSHd in your Docker containers&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id22" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id13"&gt;[6]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="http://fabiorehm.com/blog/2014/09/11/running-gui-apps-with-docker/"&gt;Running GUI apps with Docker&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id23" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id15"&gt;[7]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="https://github.com/docker/docker/issues/1916"&gt;docker build should support privileged operations&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="Docker"></category><category term="Oracle"></category><category term="容器技术"></category></entry></feed>